1. Renaming import

import { add as sum } from './math.js';

Aici importi funcÈ›ia add din math.js, dar o redenumeÈ™ti local Ã®n sum.
Practic, foloseÈ™ti un alias ca sÄƒ nu foloseÈ™ti numele original add.
FoloseÈ™ti cÃ¢nd vrei sÄƒ eviÈ›i conflicte de nume sau sÄƒ ai un nume mai clar Ã®n contextul tÄƒu.


console.log(sum(2, 3)); // foloseÈ™ti sum Ã®n loc de add

2. Namespace import

import * as math from './math.js';

Aici imporÈ›i toate exporturile din math.js sub un singur obiect numit math.
AÈ™a accesezi funcÈ›iile sau constantele cu math.add(), math.substract(), etc.
Ideal cÃ¢nd vrei sÄƒ grupezi toate funcÈ›ionalitÄƒÈ›ile unui modul sub un singur nume, clar È™i organizat.


ÃntrebÄƒri frecvente

Ce diferenÈ›Äƒ este Ã®ntre module.exports (CommonJS) È™i export (ESM)?

module.exports este specific Node.js (CommonJS). ES Modules (export) sunt standardul modern È™i funcÈ›ioneazÄƒ nativ Ã®n browser. Transpilatoarele pot converti Ã®ntre ele.



Pot avea mai multe default export Ã®ntr-un fiÈ™ier?

Nu, un fiÈ™ier poate avea doar un singur export implicit (export default).



Sunt clasele mai lente decÃ¢t obiectele simple?

DiferenÈ›ele de performanÈ›Äƒ sunt minime. Alege classes pentru OOP clar È™i obiecte simple pentru structurÄƒ de date.



CÃ¢nd sÄƒ folosesc closure vs class?
Closure pentru funcÈ›ii factory uÈ™oare È™i incapsulare simplÄƒ.
â€¢ Class cÃ¢nd ai nevoie de moÈ™tenire, instanÈ›e multiple È™i OOP structurat.

Structurile de date sunt moduri de organizare È™i stocare a datelor Ã®n memorie, astfel Ã®ncÃ¢t sÄƒ poÈ›i accesa È™i manipula eficient acele date.

ğŸ§  GÃ¢ndeÈ™te-le aÈ™a:
Ai un sertar cu documente â€” structura de date e felul Ã®n care le organizezi: Ã®n dosare (liste), pe categorii (dicÈ›ionare), Ã®n ordine alfabeticÄƒ (arbori) etc.

ğŸ“¦ Exemple de structuri de date comune:
StructurÄƒ	Ce e	Exemplu Ã®n JS
Array	listÄƒ ordonatÄƒ	[1, 2, 3]
Object	cheie â†’ valoare	{nume: 'Ana', varsta: 25}
Set	colecÈ›ie fÄƒrÄƒ duplicate	new Set([1, 2, 2, 3]) â†’ 1, 2, 3
Map	chei arbitrare â†’ valori	new Map([[1, 'unu'], [2, 'doi']])
Stack	LIFO (ultimul intrat, primul iese)	push/pop
Queue	FIFO (primul intrat, primul iese)	push/shift
Linked List, Tree, Graph	structuri avansate	folosite Ã®n algoritmi

ğŸ§© La ce folosesc?
ğŸ” CÄƒutare rapidÄƒ â†’ Map, Object

ğŸ“‹ MenÈ›inerea ordinii â†’ Array, Queue

ğŸ§® OperÄƒri matematice, backtracking â†’ Stack

ğŸ§  Reprezentare de relaÈ›ii complexe â†’ Tree, Graph

Ãntrebarea ta e foarte bunÄƒ È™i esenÈ›ialÄƒ! Hai sÄƒ o explic clar:

ğŸ¯ Care e scopul structurilor de date Ã®ntr-un proiect?
Structurile de date sunt modulul prin care organizÄƒm È™i manipulÄƒm datele Ã®ntr-un mod eficient.

GÃ¢ndeÈ™te-te la ele ca la instrumente de organizare, la fel cum ai: cutii, fiÈ™iere, rafturi, mape â€” fiecare potrivit pentru un anumit tip de informaÈ›ie sau scop.

ğŸ§  De ce sunt importante?
EficienÈ›Äƒ
DacÄƒ alegi structura potrivitÄƒ, aplicaÈ›ia e mai rapidÄƒ È™i mai simplÄƒ.

Claritate Ã®n cod
Structura bunÄƒ = cod clar, logic È™i uÈ™or de Ã®ntreÈ›inut.

RezolvÄƒ probleme reale
De exemplu:

Stack = "undo"/"redo"

Queue = procesare emailuri, mesaje

Set = eliminare duplicate din listÄƒ

Map = memorare de configurÄƒri rapide pe baza unui ID

ğŸ“¦ Exemple de aplicaÈ›ii reale
FuncÈ›ionalitate	StructurÄƒ folositÄƒ
Istoric browser / Undo	Stack
Chat / task queue	Queue
Stocare useri dupÄƒ ID	Object sau Map
Eliminare duplicate din listÄƒ	Set
Reprezentare DOM sau meniu	Tree
ReÈ›ea socialÄƒ (prieteni, conexiuni)	Graph

ğŸ§ª Cum le Ã®nveÈ›i?
Cel mai bine: le Ã®nveÈ›i prin aplicaÈ›ii concrete. De exemplu:

Faci un ToDo List? â†’ foloseÈ™ti array.

Creezi un editor de text? â†’ stack pentru undo.

Creezi un sistem de notificÄƒri? â†’ queue.

Creezi un site de produse? â†’ obiecte/map pentru produse.

Vrei sÄƒ-È›i dau o listÄƒ de mini-proiecte, fiecare concentrat pe o structurÄƒ de date?
PoÈ›i alege dintre: stack, queue, set sau altele.

âœ… Closure â€“ cÃ¢nd e ideal?
Closure-urile sunt bune pentru:

funcÈ›ii factory rapide

incapsulare simplÄƒ (ascundere variabile interne)

stare persistentÄƒ fÄƒrÄƒ clasÄƒ

cod funcÈ›ional, minimalist

ğŸ§ª Exemplu:
js
CopiazÄƒ
EditeazÄƒ
function createCounter() {
  let count = 0
  return {
    increment: () => ++count,
    reset: () => count = 0
  }
}

const counter1 = createCounter()
counter1.increment() // 1
counter1.increment() // 2
Avantaje closure:

Nu ai nevoie de new

Variabilele interne sunt private

Cod concis, uÈ™or pentru logicÄƒ simplÄƒ

âœ… Class â€“ cÃ¢nd e potrivitÄƒ?
Clasa e bunÄƒ cÃ¢nd:

ai instanÈ›e multiple de obiecte

vrei moÈ™tenire (extends)

vrei un model clar de OOP (encapsulation, inheritance, polymorphism)

foloseÈ™ti design patterns (ex: Factory, Singleton)

ğŸ§ª Exemplu:
js
CopiazÄƒ
EditeazÄƒ
class Counter {
  constructor() {
    this.count = 0
  }
  increment() {
    return ++this.count
  }
  reset() {
    this.count = 0
  }
}

const c1 = new Counter()
c1.increment() // 1
Avantaje class:

Claritate Ã®n structurÄƒ OOP

SuportÄƒ extends È™i super

BunÄƒ pentru sisteme mari È™i scalabile

ğŸ”„ Comparativ
Criteriu	Closure	Class
Scurt, rapid	âœ… Da	âŒ Mai mult boilerplate
Date private	âœ… Implicit	âŒ Trebuie workaround
InstanÈ›e multiple	âœ… Da	âœ… Da
MoÈ™tenire (extends)	âŒ Nu	âœ… Da
OOP clar	âŒ Nu	âœ… Da
Ideal pentru	FuncÈ›ii mici, factory	Sisteme mari, arhitecturÄƒ

